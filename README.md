# Coding-Test
코딩 테스트 준비(2024-03-04)

### [Lv 1. 개인정보 수집 유효기간]  
1. 년 월 일 -> 일수로 환산해 만료여부 확인!!  
2. 내 풀이는 년, 월, 일을 차례로 비교해 가며 if 중첩을 사용해 풀었다.  
3. 그리고 일자를 나타낸 문자열을 정수형으로 변환하는 구문을 함수로 만들지 않고 똑같은 표현식을 반복했다.

### [Lv 1. 가장 가까운 같은 글자]
사전과 리스트 실행속도 차이를 극명하게 보여주는 문제

### [Lv 1. 기사단원의 무기]
1. 루트연산하는데 math 모듈 사용하는 게 훨씬 빠르다.
2. 약수 집합을 set() 형식으로 관리하면 중복되는 수를 쉽게 제외시킬 수 있음!

### [Lv 1. 옹알이 (2)]  
1. 연속된 단어 체크하는 방식에서 차이가 있음.
2. 내 풀이 : 각 단어마다 대응하는 단어를 사전형태로 만듦(words = {"aya": 1, "ye": 2, "woo": 3, "ma": 4})
  -  변형된 단어를 for문으로 돌며 isdigit()과 이전 단어와 연속되는 지 확인하면서 말할 수 있는 단어인 지 체크
3. 다른 풀이 : if word*2 in bab 같은 식으로 연속된 단어가 있는 지 체크
  -  변형된 단어는 빈칸(" ")으로만 이루어졌다면(len(bab.split())==0이 True) 카운트!

### [Lv 1. 숫자 짝꿍]
1. 초반에는 for문 최소화와 시간복잡도를 줄이기 위해 dict를 최대한 활용해서 풀어보려고 했지만 계속 시간 초과가 발생
2. 시간 초과 이유 : str(int(answer)) 부분에서 발생했다..
3. Counter 모듈도 사용해봤지만 for문을 돌려 dict로 만들어 준 경우랑 크게 차이나지 않았다.(오히려 약간 느렸음)

### [Lv 1. 신고 결과 받기]
1. for문 안에 index() 메써드를 최대한 피하려고 하다보니 사전 자료형을 만들고
2. for item in set(a) 와 같이 한 줄에 형변환이 되지 않도록 풀어 쓰다보니 코드가 길어지는 경향이 있음
3. 간결하고 가독성 높은 코드에 초점을 맞춰 풀이를 작성하고 실행속도를 개선하는 것을 목표로 두어야겠음.

### [Lv 1. 로또의 최고 순위와 최저 순위]
1. 내 풀이접근 : 집합 자료형을 활용해 교집합의 개수를 카운트하고 0의 개수를 더해 최고순위를 도출한다.
2. 다른사람 풀이접근 : 순위를 나열한 리스트를 만들고 로또번호가 하나씩 맞을 때마다 순위 리스트의 인덱스를 하나씩 올려준다.

### [Lv 1. 크레인 인형뽑기 게임]
1. numpy 모듈을 사용해 풀었다.(0.56ms 10.2mb) 사실 numpy를 사용한 부분은 사전 자료형의 value를 삽입할 때 슬라이싱 부분만 사용했기 때문에 메모리만 차지하는 꼴.
2. 처음 numpy 슬라이싱과 리스트 컴프리헨션으로 사전을 만든 부분을 풀어서 코드를 작성했다.(0.29ms, 10.2mb) 이중 for문의 사용을 최소화했고 사용하더라도 내부에서 연산을 최소화하도록 작성했다.
3. 직관적으로 이중 for문 틀 안에서 인형 라인 인덱스와 인형 인덱스를 추출하고 삭제하면서 카운트를 진행한다.(0.72ms, 10.2mb) 이중 for문 안에서 복잡하거나 잡다한 연산을 많이 넣을수록 성능이 악화됨.(이중 for문을 최소화하고 쓸 경우엔 연산을 최소화!)

### [Lv 1. 비밀지도]
1. 2진법 전환할 때 while문을 통해서 구현
2. bin 내장함수를 알지 못했음
3. replace를 피하려고 했는데 사용해보니 메모리는 좀 차지하지만 속도면에선 for문으로 교체하는 것보다 빨랐음.

### [Lv 1. 최대공약수와 최소공배수]
1. 유클리드 알고리듬 공부하기 좋은 문제
2. 문제는 간단하고 정답률도 높지만 알고리즘을 아는 것과 모를 때 문제를 보는 시각이 많이 달라진다...
3. 이 문제뿐만 아니라 다른 고난도 문제에서도 써먹을 수 있는 경우가 있을 듯..
